<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Crossy Road Multiplayer - Gravity Gun Mod</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #333;
      font-family: sans-serif;
    }
    /* Login UI styling */
    #loginContainer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #222;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }
    #loginContainer input, #loginContainer button {
      font-size: 18px;
      padding: 8px;
      margin: 5px;
    }
    #avatarCanvas {
      border: 1px solid #fff;
      background: #fff;
      cursor: crosshair;
    }
    /* Hide game canvas during login */
    #gameCanvas {
      display: none;
    }
    /* Score display */
    #scoreDisplay {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #fff;
      font-size: 24px;
      font-weight: bold;
      text-shadow: 2px 2px 4px #000;
      z-index: 5;
    }
    /* Moderator Panel (only for mod "pode") */
    #modPanel {
      position: absolute;
      right: 10px;
      top: 50px;
      background: rgba(0,0,0,0.8);
      color: #fff;
      padding: 10px;
      border-radius: 8px;
      z-index: 20;
      font-size: 14px;
      display: none;
      max-width: 250px;
    }
    #modPanel select, #modPanel input, #modPanel button {
      width: 100%;
      margin: 3px 0;
      padding: 4px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <!-- Login Screen -->
  <div id="loginContainer">
    <h1>Crossy Road Multiplayer - Gravity Gun Mod</h1>
    <input type="text" id="playerName" placeholder="Enter your name" />
    <p>Draw your avatar (a square face):</p>
    <canvas id="avatarCanvas" width="100" height="100"></canvas>
    <div>
      <button id="clearAvatar">Clear Drawing</button>
      <button id="startGame">Go</button>
    </div>
  </div>
  
  <!-- Moderator Panel (only visible for mod "pode") -->
  <div id="modPanel">
    <h3>Moderator Panel</h3>
    <select id="modTargetSelect"></select>
    <button id="modResetBtn">Reset Player</button>
    <button id="modKickBtn">Kick Player</button>
    <input type="text" id="modChangeName" placeholder="New name" />
    <button id="modChangeNameBtn">Change Name</button>
    <input type="text" id="modAlertMsg" placeholder="Alert message" />
    <button id="modAlertBtn">Send Alert</button>
    <button id="modRefreshBtn">Refresh List</button>
  </div>
  
  <!-- Score Display -->
  <div id="scoreDisplay">Score: 0</div>
  <!-- Game Canvas -->
  <canvas id="gameCanvas"></canvas>
  
  <script type="module">
    // ----- Firebase Setup -----
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-app.js";
    import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-analytics.js";
    import { getDatabase, ref, onValue, set, update, onDisconnect, push, remove } from "https://www.gstatic.com/firebasejs/11.6.0/firebase-database.js";
    
    const firebaseConfig = {
      apiKey: "AIzaSyAuWY5GDgH2_-iiNCluN89cjsip19qIpGM",
      authDomain: "fortnite-64ecb.firebaseapp.com",
      databaseURL: "https://fortnite-64ecb-default-rtdb.firebaseio.com",
      projectId: "fortnite-64ecb",
      storageBucket: "fortnite-64ecb.firebasestorage.app",
      messagingSenderId: "643049506369",
      appId: "1:643049506369:web:15e6e0bbf6bd0462bca8c0",
      measurementId: "G-KGWJWD3Z3C"
    };
    const app = initializeApp(firebaseConfig);
    const analytics = getAnalytics(app);
    const db = getDatabase(app);
    
    // ----- Global Constants & Variables -----
    const blockSize = 50; // one block equals 50px
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    let canvasWidth = window.innerWidth;
    let canvasHeight = window.innerHeight;
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    window.addEventListener("resize", () => {
      canvasWidth = window.innerWidth;
      canvasHeight = window.innerHeight;
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
    });
    
    const scoreDisplay = document.getElementById("scoreDisplay");
    const modPanel = document.getElementById("modPanel");
    const modTargetSelect = document.getElementById("modTargetSelect");
    const modResetBtn = document.getElementById("modResetBtn");
    const modKickBtn = document.getElementById("modKickBtn");
    const modChangeName = document.getElementById("modChangeName");
    const modChangeNameBtn = document.getElementById("modChangeNameBtn");
    const modAlertMsg = document.getElementById("modAlertMsg");
    const modAlertBtn = document.getElementById("modAlertBtn");
    const modRefreshBtn = document.getElementById("modRefreshBtn");
    
    // Particle system for effects
    let particles = [];
    function spawnParticle(x, y, color) {
      particles.push({
        x: x,
        y: y,
        vx: (Math.random() - 0.5) * 2,
        vy: (Math.random() - 0.5) * 2,
        life: 100,
        color: color
      });
    }
    function updateParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx * dt * 0.01;
        p.y += p.vy * dt * 0.01;
        p.life -= dt;
        if (p.life <= 0) particles.splice(i, 1);
      }
    }
    function renderParticles() {
      particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = Math.max(p.life / 100, 0);
        ctx.beginPath();
        ctx.arc(p.x - 0, p.y - cameraOffsetY, 3, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1;
    }
    
    // Shared seed for world generation
    let seed;
    const seedRef = ref(db, "lobbies/crossyLobby/seed");
    onValue(seedRef, snapshot => {
      if (snapshot.exists()) {
        seed = snapshot.val();
      } else {
        seed = Math.floor(Math.random() * 1000000);
        set(seedRef, seed);
      }
    });
    function seededRandom(s) {
      let x = Math.sin(s) * 10000;
      return x - Math.floor(x);
    }
    function randomWithSeed(offset) {
      return seededRandom(seed + offset);
    }
    
    // ----- Login & Avatar Drawing -----
    const loginContainer = document.getElementById("loginContainer");
    const playerNameInput = document.getElementById("playerName");
    const avatarCanvas = document.getElementById("avatarCanvas");
    const avatarCtx = avatarCanvas.getContext("2d");
    const clearAvatarBtn = document.getElementById("clearAvatar");
    const startGameBtn = document.getElementById("startGame");
    
    let drawing = false;
    avatarCanvas.addEventListener("mousedown", (e) => {
      drawing = true;
      avatarCtx.lineWidth = 4;
      avatarCtx.lineCap = "round";
      avatarCtx.strokeStyle = "#000";
      avatarCtx.beginPath();
      avatarCtx.moveTo(e.offsetX, e.offsetY);
    });
    avatarCanvas.addEventListener("mousemove", (e) => {
      if (drawing) {
        avatarCtx.lineTo(e.offsetX, e.offsetY);
        avatarCtx.stroke();
      }
    });
    avatarCanvas.addEventListener("mouseup", () => drawing = false);
    avatarCanvas.addEventListener("mouseleave", () => drawing = false);
    clearAvatarBtn.addEventListener("click", () => {
      avatarCtx.clearRect(0, 0, avatarCanvas.width, avatarCanvas.height);
      avatarCtx.fillStyle = "#fff";
      avatarCtx.fillRect(0, 0, avatarCanvas.width, avatarCanvas.height);
    });
    clearAvatarBtn.click();
    
    // ----- Player Object & Initialization -----
    let player = {
      name: "",
      avatar: "",
      gridX: 0,
      gridY: 0,
      alive: true,
      score: 0,
      // For gravity gun (for mod "reed")
      gravityGunMode: "none", // "forth", "back", or "none"
      gunAngle: 0,
      isMod: false,
      modAlert: ""
    };
    let playerId = '_' + Math.random().toString(36).substr(2, 9);
    
    // Multiplayer players
    let otherPlayers = {};
    const lobbyPlayersRef = ref(db, "lobbies/crossyLobby/players");
    onValue(lobbyPlayersRef, snapshot => {
      const data = snapshot.val();
      if (data) {
        otherPlayers = data;
        if (player.isMod) refreshModTargetList();
      }
    });
    
    // ----- World Generation Functions -----
    // Lane types: "train", "road", "land"
    function getLaneType(row) {
      const startingRow = player.startRow;
      if (row >= startingRow) return "land";
      let r = randomWithSeed(row);
      if (r < 0.1) return "train";
      else if (r < 0.5) return "road";
      else return "land";
    }
    function getTreesForLane(row) {
      let trees = [];
      let numCols = Math.floor(canvasWidth / blockSize);
      for (let col = 0; col < numCols; col++) {
        if (randomWithSeed(row * 100 + col) < 0.2) {
          trees.push(col);
        }
      }
      return trees;
    }
    function getCarsForLane(row) {
      if (getLaneType(row) !== "road") return [];
      let cars = [];
      let numCars = Math.floor(randomWithSeed(row * 2) * 3) + 2;
      let direction = (row % 2 === 0) ? "right" : "left";
      let baseSpeed = 2 + randomWithSeed(row * 3) * 3;
      for (let i = 0; i < numCars; i++) {
        let speedMultiplier = 3 + randomWithSeed(row * 10 + i) * 0.5;
        let finalSpeed = baseSpeed * speedMultiplier;
        let spacing = canvasWidth / numCars;
        let x = spacing * i + randomWithSeed(row * 10 + i) * spacing;
        let carWidth = 60;
        let carHeight = blockSize * 0.8;
        cars.push({
          x: x,
          y: row * blockSize + (blockSize - carHeight) / 2,
          width: carWidth,
          height: carHeight,
          speed: finalSpeed * (direction === "left" ? -1 : 1)
        });
      }
      return cars;
    }
    const trainCycle = 10000;
    function getTrainEvent(row) {
      let offset = randomWithSeed(row + 1000) * trainCycle;
      let t = (Date.now() + offset) % trainCycle;
      if (t < 2000) return { state: "warning" };
      else if (t < 2200) {
        let timeFactor = (t - 2000) / 200;
        let x = ((timeFactor * (canvasWidth + 200)) - 200);
        return { state: "active", x: x, width: 200, height: blockSize * 0.8 };
      } else return { state: "cooldown" };
    }
    
    // ----- Gravity Gun for Moderator ("reed") -----
    // If a mod is active (player.isMod === true), then key 1 sets gravityGunMode to "forth" (red),
    // key 2 sets it to "back" (blue), and key 3 puts it away.
    window.addEventListener("keydown", (e) => {
      // Only for mod users
      if (player.isMod) {
        if (e.key === "1") {
          player.gravityGunMode = "forth";
          update(ref(db, "lobbies/crossyLobby/players/" + playerId), { gravityGunMode: player.gravityGunMode });
        } else if (e.key === "2") {
          player.gravityGunMode = "back";
          update(ref(db, "lobbies/crossyLobby/players/" + playerId), { gravityGunMode: player.gravityGunMode });
        } else if (e.key === "3") {
          player.gravityGunMode = "none";
          update(ref(db, "lobbies/crossyLobby/players/" + playerId), { gravityGunMode: player.gravityGunMode });
        }
      }
    });
    
    // Update gun angle on mouse move if mod and gravity gun is active
    document.addEventListener("mousemove", (e) => {
      if (player.isMod && player.gravityGunMode !== "none") {
        let pCenterX = player.gridX * blockSize + blockSize/2;
        let pCenterY = player.gridY * blockSize + blockSize/2;
        // Convert mouse coordinates to world (add camera offset in y)
        let worldMouseX = e.clientX;
        let worldMouseY = e.clientY + cameraOffsetY;
        let dx = worldMouseX - pCenterX;
        let dy = worldMouseY - pCenterY;
        let angle = Math.atan2(dy, dx);
        player.gunAngle = angle;
        update(ref(db, "lobbies/crossyLobby/players/" + playerId), { gunAngle: player.gunAngle });
      }
    });
    
    // On mouse click, if mod with gravity gun active, check for target and apply effect
    document.addEventListener("mousedown", (e) => {
      if (player.isMod && player.gravityGunMode !== "none") {
        // Determine click world coordinates
        let clickX = e.clientX;
        let clickY = e.clientY + cameraOffsetY;
        // Check if click falls within any other player's block
        for (let id in otherPlayers) {
          if (id === playerId) continue;
          let op = otherPlayers[id];
          let opX = op.gridX * blockSize;
          let opY = op.gridY * blockSize;
          if (clickX >= opX && clickX <= opX + blockSize &&
              clickY >= opY && clickY <= opY + blockSize && op.alive) {
            // Gravity effect: compute direction relative to mod
            let modCenterX = player.gridX;
            let modCenterY = player.gridY;
            let dx = op.gridX - modCenterX;
            let dy = op.gridY - modCenterY;
            // For "forth" mode, pull one block closer; for "back" mode, push one block away.
            let newX = op.gridX;
            let newY = op.gridY;
            if (player.gravityGunMode === "forth") {
              newX -= (dx > 0) ? 1 : (dx < 0 ? -1 : 0);
              newY -= (dy > 0) ? 1 : (dy < 0 ? -1 : 0);
            } else if (player.gravityGunMode === "back") {
              newX += (dx > 0) ? 1 : (dx < 0 ? -1 : 0);
              newY += (dy > 0) ? 1 : (dy < 0 ? -1 : 0);
            }
            // Update the target player's position in Firebase.
            update(ref(db, "lobbies/crossyLobby/players/" + id), { gridX: newX, gridY: newY });
            // Spawn particles at target center.
            spawnParticle(opX + blockSize/2, opY + blockSize/2, (player.gravityGunMode === "forth") ? "red" : "blue");
          }
        }
      }
    });
    
    // ----- Moderator Panel Functions -----
    function refreshModTargetList() {
      // Populate the mod target dropdown with other players
      modTargetSelect.innerHTML = "";
      for (let id in otherPlayers) {
        if (id === playerId) continue;
        let option = document.createElement("option");
        option.value = id;
        option.textContent = otherPlayers[id].name || "Anon";
        modTargetSelect.appendChild(option);
      }
    }
    modRefreshBtn.addEventListener("click", refreshModTargetList);
    modResetBtn.addEventListener("click", () => {
      let targetId = modTargetSelect.value;
      if (targetId) respawnPlayer(targetId);
    });
    modKickBtn.addEventListener("click", () => {
      let targetId = modTargetSelect.value;
      if (targetId) remove(ref(db, "lobbies/crossyLobby/players/" + targetId));
    });
    modChangeNameBtn.addEventListener("click", () => {
      let targetId = modTargetSelect.value;
      if (targetId && modChangeName.value.trim() !== "") {
        update(ref(db, "lobbies/crossyLobby/players/" + targetId), { name: modChangeName.value.trim() });
      }
    });
    modAlertBtn.addEventListener("click", () => {
      let targetId = modTargetSelect.value;
      if (targetId && modAlertMsg.value.trim() !== "") {
        update(ref(db, "lobbies/crossyLobby/players/" + targetId), { modAlert: modAlertMsg.value.trim() });
      }
    });
    
    // ----- Input: Discrete Movement with Tree Collision -----
    let moveLock = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
    window.addEventListener("keydown", (e) => {
      if (!moveLock[e.key] && ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
        let newX = player.gridX;
        let newY = player.gridY;
        if (e.key === "ArrowUp") newY -= 1;
        if (e.key === "ArrowDown") newY += 1;
        if (e.key === "ArrowLeft") newX -= 1;
        if (e.key === "ArrowRight") newX += 1;
        let numCols = Math.floor(canvasWidth / blockSize);
        if (newX < 0 || newX >= numCols) {
          moveLock[e.key] = true;
          return;
        }
        if (getLaneType(newY) === "land") {
          let trees = getTreesForLane(newY);
          if (trees.includes(newX)) {
            moveLock[e.key] = true;
            return;
          }
        }
        player.gridX = newX;
        player.gridY = newY;
        let newScore = player.startRow - player.gridY;
        if (newScore > player.score) {
          player.score = newScore;
        }
        update(ref(db, "lobbies/crossyLobby/players/" + playerId), player);
        moveLock[e.key] = true;
      }
    });
    window.addEventListener("keyup", (e) => {
      if (moveLock[e.key]) moveLock[e.key] = false;
    });
    
    // ----- Player Death & Respawn -----
    function respawnPlayer(targetId) {
      if (targetId === playerId) {
        player.alive = false;
        update(ref(db, "lobbies/crossyLobby/players/" + playerId), player);
        setTimeout(() => {
          let numCols = Math.floor(canvasWidth / blockSize);
          player.gridX = Math.floor(numCols / 2);
          player.gridY = player.startRow;
          player.alive = true;
          update(ref(db, "lobbies/crossyLobby/players/" + playerId), player);
        }, 1000);
      } else {
        update(ref(db, "lobbies/crossyLobby/players/" + targetId), { alive: false });
      }
    }
    
    // ----- Check for Mod Alerts for Local Player -----
    onValue(ref(db, "lobbies/crossyLobby/players/" + playerId + "/modAlert"), snapshot => {
      if (snapshot.exists()) {
        let msg = snapshot.val();
        alert("Moderator says: " + msg);
        update(ref(db, "lobbies/crossyLobby/players/" + playerId), { modAlert: "" });
      }
    });
    
    // ----- Rendering & Game Loop -----
    let cameraOffsetY = 0;
    let lastFrameTime = Date.now();
    function renderGame() {
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      let playerPixelX = player.gridX * blockSize;
      let playerPixelY = player.gridY * blockSize;
      let targetOffsetY = playerPixelY - canvasHeight * 0.7;
      cameraOffsetY += (targetOffsetY - cameraOffsetY) * 0.1;
      let startRow = Math.floor(cameraOffsetY / blockSize);
      let numRows = Math.ceil(canvasHeight / blockSize) + 1;
      
      for (let row = startRow; row < startRow + numRows; row++) {
        let laneType = getLaneType(row);
        let yPos = row * blockSize - cameraOffsetY;
        if (laneType === "road") {
          ctx.fillStyle = "#444";
          ctx.fillRect(0, yPos, canvasWidth, blockSize);
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 2;
          ctx.setLineDash([10, 10]);
          ctx.beginPath();
          ctx.moveTo(0, yPos + blockSize/2);
          ctx.lineTo(canvasWidth, yPos + blockSize/2);
          ctx.stroke();
          ctx.setLineDash([]);
        } else if (laneType === "land") {
          let grd = ctx.createLinearGradient(0, yPos, 0, yPos + blockSize);
          grd.addColorStop(0, "#76c893");
          grd.addColorStop(1, "#4caf50");
          ctx.fillStyle = grd;
          ctx.fillRect(0, yPos, canvasWidth, blockSize);
          let trees = getTreesForLane(row);
          for (let col of trees) {
            let treeX = col * blockSize;
            ctx.fillStyle = "#8B4513";
            ctx.fillRect(treeX + blockSize * 0.4, yPos + blockSize * 0.5, blockSize * 0.2, blockSize * 0.5);
            ctx.fillStyle = "#228B22";
            ctx.beginPath();
            ctx.arc(treeX + blockSize * 0.5, yPos + blockSize * 0.4, blockSize * 0.3, 0, Math.PI * 2);
            ctx.fill();
          }
        } else if (laneType === "train") {
          ctx.fillStyle = "#666";
          ctx.fillRect(0, yPos, canvasWidth, blockSize);
          let train = getTrainEvent(row);
          if (train.state === "warning") {
            if (Math.floor(Date.now()/200) % 2 === 0) {
              ctx.fillStyle = "rgba(255,0,0,0.5)";
              ctx.fillRect(0, yPos, canvasWidth, blockSize);
            }
          } else if (train.state === "active") {
            let x = train.x;
            ctx.fillStyle = "#FF9800";
            ctx.fillRect(x, yPos + (blockSize - train.height)/2, train.width, train.height);
            if (player.alive && player.gridY === row) {
              let playerRect = { x: player.gridX * blockSize, y: yPos, width: blockSize, height: blockSize };
              let trainRect = { x: x, y: yPos + (blockSize - train.height)/2, width: train.width, height: train.height };
              if (playerRect.x < trainRect.x + trainRect.width &&
                  playerRect.x + playerRect.width > trainRect.x &&
                  playerRect.y < trainRect.y + trainRect.height &&
                  playerRect.y + playerRect.height > trainRect.y) {
                respawnPlayer(playerId);
              }
            }
          }
        }
        if (laneType === "road") {
          let cars = getCarsForLane(row);
          for (let car of cars) {
            let t = Date.now() / 50;
            let pos = car.x + car.speed * t;
            pos = ((pos % (canvasWidth + car.width)) + (canvasWidth + car.width)) % (canvasWidth + car.width) - car.width;
            ctx.fillStyle = "#e53935";
            ctx.fillRect(pos, yPos + (blockSize - car.height)/2, car.width, car.height);
            ctx.fillStyle = "#fff";
            ctx.fillRect(pos + 10, yPos + (blockSize - car.height)/2 + 5, car.width - 20, car.height/2);
            if (player.alive && player.gridY === row) {
              let playerRect = { x: player.gridX * blockSize, y: yPos, width: blockSize, height: blockSize };
              let carRect = { x: pos, y: yPos + (blockSize - car.height)/2, width: car.width, height: car.height };
              if (playerRect.x < carRect.x + carRect.width &&
                  playerRect.x + playerRect.width > carRect.x &&
                  playerRect.y < carRect.y + carRect.height &&
                  playerRect.y + playerRect.height > carRect.y) {
                respawnPlayer(playerId);
              }
            }
          }
        }
      }
      
      // Draw particles
      renderParticles();
      
      // Draw other players
      for (let id in otherPlayers) {
        if (id === playerId) continue;
        const op = otherPlayers[id];
        let opX = op.gridX * blockSize;
        let opY = op.gridY * blockSize - cameraOffsetY;
        if (op.avatar) {
          let img = new Image();
          img.src = op.avatar;
          ctx.drawImage(img, opX, opY, blockSize, blockSize);
        } else {
          ctx.fillStyle = "#fff";
          ctx.fillRect(opX, opY, blockSize, blockSize);
        }
        ctx.fillStyle = "#000";
        ctx.font = "12px sans-serif";
        ctx.fillText(op.name || "Anon", opX, opY + 12);
        // If a mod has a gravity gun active, draw the gun indicator.
        if (op.isMod && op.gravityGunMode && op.gravityGunMode !== "none" && op.gunAngle !== undefined) {
          let centerX = opX + blockSize/2;
          let centerY = opY + blockSize/2;
          let gunLength = 30;
          let endX = centerX + Math.cos(op.gunAngle) * gunLength;
          let endY = centerY + Math.sin(op.gunAngle) * gunLength;
          ctx.strokeStyle = (op.gravityGunMode === "forth") ? "red" : "blue";
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(endX, endY);
          ctx.stroke();
        }
      }
      
      // Draw local player
      let localX = player.gridX * blockSize;
      let localY = player.gridY * blockSize - cameraOffsetY;
      if (player.avatar) {
        let img = new Image();
        img.src = player.avatar;
        ctx.drawImage(img, localX, localY, blockSize, blockSize);
      } else {
        ctx.fillStyle = "#ff0";
        ctx.fillRect(localX, localY, blockSize, blockSize);
      }
      ctx.fillStyle = "#000";
      ctx.font = "12px sans-serif";
      ctx.fillText(player.name, localX, localY + 12);
      if (player.isMod && player.gravityGunMode !== "none" && player.gunAngle !== undefined) {
        let centerX = localX + blockSize/2;
        let centerY = localY + blockSize/2;
        let gunLength = 30;
        let endX = centerX + Math.cos(player.gunAngle) * gunLength;
        let endY = centerY + Math.sin(player.gunAngle) * gunLength;
        ctx.strokeStyle = (player.gravityGunMode === "forth") ? "red" : "blue";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
      }
      
      scoreDisplay.textContent = "Score: " + player.score;
    }
    
    function gameLoop() {
      let now = Date.now();
      let dt = now - lastFrameTime;
      lastFrameTime = now;
      updateParticles(dt);
      renderGame();
      requestAnimationFrame(gameLoop);
    }
    
    // ----- Start Game After Login -----
    startGameBtn.addEventListener("click", () => {
      const name = playerNameInput.value.trim();
      if (!name) {
        alert("Please enter a name!");
        return;
      }
      // If name is "reed", give mod privileges and set inâ€“game name to "pode"
      if (name.toLowerCase() === "reed") {
        player.name = "pode";
        player.isMod = true;
        player.gravityGunMode = "none";
        player.gunAngle = 0;
        modPanel.style.display = "block";
      } else {
        player.name = name;
      }
      player.avatar = avatarCanvas.toDataURL();
      player.startRow = Math.floor(canvasHeight / blockSize) - 1;
      let numCols = Math.floor(canvasWidth / blockSize);
      player.gridX = Math.floor(numCols / 2);
      player.gridY = player.startRow;
      player.score = 0;
      
      const playerRef = ref(db, "lobbies/crossyLobby/players/" + playerId);
      set(playerRef, player);
      onDisconnect(playerRef).remove();
      
      loginContainer.style.display = "none";
      canvas.style.display = "block";
      
      lastFrameTime = Date.now();
      gameLoop();
    });
    
  </script>
</body>
</html>
