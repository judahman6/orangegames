<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Top Down Tank Game â€“ Multiple Guns</title>
  <!-- Load Phaser 3 -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
  <style>
    body { margin: 0; overflow: hidden; }
    /* Fullscreen game container */
    #game-container {
      width: 100vw;
      height: 100vh;
      display: none;
    }
    /* Centered overlay for login */
    #login-container {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 300px;
      background: rgba(0,0,0,0.8);
      color: #fff;
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      z-index: 1001;
    }
    #login-container input {
      width: 80%;
      padding: 8px;
      margin: 10px 0;
    }
    #login-container button {
      padding: 8px 16px;
    }
  </style>
</head>
<body>
  <!-- Login Overlay -->
  <div id="login-container">
    <h2>Login</h2>
    <input type="text" id="username-input" placeholder="Enter your username" />
    <br/>
    <button id="login-button">Start Game</button>
  </div>
  
  <!-- Game Container -->
  <div id="game-container"></div>
  
  <script type="module">
    // Import Firebase modules
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-app.js";
    import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-analytics.js";
    import { getDatabase, ref, set, onChildAdded, onChildChanged, onChildRemoved, push } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-database.js";
    
    // Firebase configuration (using the same config as before)
    const firebaseConfig = {
      apiKey: "AIzaSyCssnOBJd20Q46CVF4iuuygLeqaMCqInhk",
      authDomain: "platformer-e205c.firebaseapp.com",
      projectId: "platformer-e205c",
      storageBucket: "platformer-e205c.firebasestorage.app",
      messagingSenderId: "350613298525",
      appId: "1:350613298525:web:dddba101b6545241dadcb4",
      measurementId: "G-3DT5KYV4MS"
    };
    
    // Initialize Firebase
    const appFirebase = initializeApp(firebaseConfig);
    const analytics = getAnalytics(appFirebase);
    const db = getDatabase(appFirebase);
    
    // Global login variables
    let username = "";
    let playerId = "";
    
    // Login handling
    const loginButton = document.getElementById("login-button");
    loginButton.addEventListener("click", () => {
      const input = document.getElementById("username-input").value.trim();
      if (input !== "") {
        username = input;
        playerId = "player_" + Math.floor(Math.random() * 10000);
        document.getElementById("login-container").style.display = "none";
        document.getElementById("game-container").style.display = "block";
        startGame();
      }
    });
    
    // --- Game Code ---
    function startGame() {
      const config = {
        type: Phaser.AUTO,
        parent: "game-container",
        scale: {
          mode: Phaser.Scale.FIT,
          autoCenter: Phaser.Scale.CENTER_BOTH,
          width: 800,
          height: 600,
        },
        physics: {
          default: "arcade",
          arcade: { gravity: { x: 0, y: 0 }, debug: false }
        },
        scene: { preload: preload, create: create, update: update }
      };
      
      const game = new Phaser.Game(config);
      
      let localTank;
      let localHealthBar; // Graphics object for local tank's health bar
      let keys, spaceKey, weaponKeys;
      let localWeaponText; // HUD text for current weapon
      let currentWeapon = 1; // 1 = Normal, 2 = RPG, 3 = Rapid Fire
      let bulletGroup;
      let bulletMap = {};  // Track bullets from Firebase
      let otherPlayers = {};  // Remote players
      
      // Crate group (obstacles)
      let crates;
      
      // Game parameters
      const TANK_SPEED = 150;
      const TANK_ROTATION_SPEED = 0.04; // radians per frame
      const BASE_HEALTH = 100;
      
      // Weapon parameters
      const normalDamage = 25;
      const normalCooldown = 500;
      const normalSpeed = 300;
      
      const rpgDamage = 25; // Direct hit damage (explosion does area damage)
      const rpgCooldown = 1000;
      const rpgSpeed = 200;
      const explosionRadius = 75;
      const explosionDamage = 50;
      
      const rapidDamage = 15;
      const rapidCooldown = 200;
      const rapidSpeed = 300;
      
      let lastShotTime = 0;
      let gameOverTriggered = false;
      
      // Helper function to draw a health bar above a tank
      function drawHealthBar(tank, healthBar, currentHealth, maxHealth) {
        let barWidth = 40;
        let barHeight = 6;
        let x = tank.x - barWidth / 2;
        let y = tank.y - tank.displayHeight/2 - 10;
        healthBar.clear();
        // Draw border/background
        healthBar.fillStyle(0x000000);
        healthBar.fillRect(x, y, barWidth, barHeight);
        // Draw health (green)
        let healthPercent = Phaser.Math.Clamp(currentHealth / maxHealth, 0, 1);
        healthBar.fillStyle(0x00ff00);
        healthBar.fillRect(x + 1, y + 1, (barWidth - 2) * healthPercent, barHeight - 2);
      }
      
      function preload() {
        // No tile sprite background; we'll set the camera to a basic grey.
        // Create custom tank art using Phaser graphics
        const tankGraphics = this.make.graphics({ x: 0, y: 0, add: false });
        // Draw tank body with rounded corners
        tankGraphics.fillStyle(0x333333, 1);
        tankGraphics.fillRoundedRect(0, 0, 60, 30, 5);
        // Draw tank turret (a circle in the center)
        tankGraphics.fillStyle(0x777777, 1);
        tankGraphics.fillCircle(30, 15, 8);
        // Add a cannon barrel protruding from the body
        tankGraphics.fillStyle(0x555555, 1);
        tankGraphics.fillRect(38, 13, 20, 4);
        tankGraphics.generateTexture("tank", 60, 30);
        
        // Create custom bullet art (all bullets use the same art)
        const bulletGraphics = this.make.graphics({ x: 0, y: 0, add: false });
        bulletGraphics.fillStyle(0xff4500, 1);
        bulletGraphics.fillCircle(4, 4, 4);
        bulletGraphics.generateTexture("bullet", 8, 8);
        
        // Create custom crate art
        const crateGraphics = this.make.graphics({ x: 0, y: 0, add: false });
        crateGraphics.fillStyle(0x8B4513, 1); // brown color
        crateGraphics.fillRect(0, 0, 50, 50);
        crateGraphics.lineStyle(2, 0x000000, 1);
        crateGraphics.strokeRect(0, 0, 50, 50);
        crateGraphics.generateTexture("crate", 50, 50);
      }
      
      function create() {
        const scene = this;
        // Set camera background to basic grey
        this.cameras.main.setBackgroundColor(0x808080);
        
        // Create crates (static obstacles) and add them to a static group
        crates = this.physics.add.staticGroup();
        // Place crates at fixed positions
        crates.create(150, 150, "crate");
        crates.create(650, 150, "crate");
        crates.create(150, 450, "crate");
        crates.create(650, 450, "crate");
        crates.create(400, 300, "crate");
        
        // Create the local tank at the center of the screen
        localTank = this.physics.add.sprite(this.cameras.main.width / 2, this.cameras.main.height / 2, "tank");
        localTank.setCollideWorldBounds(true);
        localTank.health = BASE_HEALTH;
        localTank.maxHealth = BASE_HEALTH;
        localTank.setOrigin(0.5);
        
        // Create a graphics object for the local tank's health bar
        localHealthBar = this.add.graphics();
        
        // Enable collision between the local tank and crates
        this.physics.add.collider(localTank, crates);
        
        // Create a group for bullets
        bulletGroup = this.physics.add.group();
        
        // Set up keyboard input: WASD for movement and space for shooting
        keys = this.input.keyboard.addKeys({
          w: Phaser.Input.Keyboard.KeyCodes.W,
          a: Phaser.Input.Keyboard.KeyCodes.A,
          s: Phaser.Input.Keyboard.KeyCodes.S,
          d: Phaser.Input.Keyboard.KeyCodes.D
        });
        spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
        
        // Set up weapon selection keys (1, 2, 3)
        weaponKeys = this.input.keyboard.addKeys({
          one: Phaser.Input.Keyboard.KeyCodes.ONE,
          two: Phaser.Input.Keyboard.KeyCodes.TWO,
          three: Phaser.Input.Keyboard.KeyCodes.THREE
        });
        // Display current weapon in HUD
        localWeaponText = this.add.text(10, 30, "Weapon: Normal", { fontSize: '16px', fill: '#fff' });
        
        // Firebase listeners for players
        const playersRef = ref(db, "players");
        onChildAdded(playersRef, (data) => {
          const pid = data.key;
          if (pid === playerId) return; // Skip local player
          const dataVal = data.val();
          if (!otherPlayers[pid]) {
            const remote = scene.physics.add.sprite(dataVal.x, dataVal.y, "tank");
            remote.setCollideWorldBounds(true);
            remote.health = dataVal.health;
            remote.maxHealth = BASE_HEALTH;
            remote.rotation = dataVal.rotation;
            scene.physics.add.collider(remote, crates);
            let healthBar = scene.add.graphics();
            otherPlayers[pid] = { sprite: remote, healthBar: healthBar, lastPing: dataVal.lastPing, username: dataVal.username };
          }
        });
        
        onChildChanged(playersRef, (data) => {
          const pid = data.key;
          if (pid === playerId) return;
          const dataVal = data.val();
          if (otherPlayers[pid]) {
            const remote = otherPlayers[pid].sprite;
            remote.x = dataVal.x;
            remote.y = dataVal.y;
            remote.rotation = dataVal.rotation;
            remote.health = dataVal.health;
            otherPlayers[pid].lastPing = dataVal.lastPing;
            otherPlayers[pid].username = dataVal.username;
            if (remote.health <= 0) {
              remote.destroy();
              otherPlayers[pid].healthBar.destroy();
              delete otherPlayers[pid];
            }
          }
        });
        
        onChildRemoved(playersRef, (data) => {
          const pid = data.key;
          if (otherPlayers[pid]) {
            otherPlayers[pid].sprite.destroy();
            otherPlayers[pid].healthBar.destroy();
            delete otherPlayers[pid];
          }
        });
        
        // Firebase listeners for bullets
        const bulletsRef = ref(db, "bullets");
        bulletMap = {};
        onChildAdded(bulletsRef, (data) => {
          if (bulletMap[data.key]) return;
          const bData = data.val();
          const bullet = bulletGroup.create(bData.x, bData.y, "bullet");
          bullet.shooter = bData.shooter;
          bullet.weaponType = bData.weapon; // 1, 2, or 3
          bullet.damage = bData.damage;
          bullet.body.allowGravity = false;
          bullet.setVelocity(bData.vx, bData.vy);
          bullet.bulletId = data.key;
          bulletMap[data.key] = bullet;
        });
        onChildRemoved(bulletsRef, (data) => {
          if (bulletMap[data.key]) {
            bulletMap[data.key].destroy();
            delete bulletMap[data.key];
          }
        });
      }
      
      function update(time, delta) {
        let scene = this; // alias for use in helper functions
        
        // --- Weapon Selection ---
        if (Phaser.Input.Keyboard.JustDown(weaponKeys.one)) {
          currentWeapon = 1;
          localWeaponText.setText("Weapon: Normal");
        }
        if (Phaser.Input.Keyboard.JustDown(weaponKeys.two)) {
          currentWeapon = 2;
          localWeaponText.setText("Weapon: RPG");
        }
        if (Phaser.Input.Keyboard.JustDown(weaponKeys.three)) {
          currentWeapon = 3;
          localWeaponText.setText("Weapon: Rapid Fire");
        }
        
        // --- Tank Movement (WASD) ---
        localTank.setVelocity(0);
        if (keys.a.isDown) {
          localTank.rotation -= TANK_ROTATION_SPEED;
        }
        if (keys.d.isDown) {
          localTank.rotation += TANK_ROTATION_SPEED;
        }
        if (keys.w.isDown) {
          localTank.body.velocity.x = Math.cos(localTank.rotation) * TANK_SPEED;
          localTank.body.velocity.y = Math.sin(localTank.rotation) * TANK_SPEED;
        }
        if (keys.s.isDown) {
          localTank.body.velocity.x = -Math.cos(localTank.rotation) * TANK_SPEED;
          localTank.body.velocity.y = -Math.sin(localTank.rotation) * TANK_SPEED;
        }
        
        // --- Shooting ---
        let bulletSpeedUsed, bulletDamageUsed, cooldownUsed;
        switch(currentWeapon) {
          case 1:
            bulletSpeedUsed = normalSpeed;
            bulletDamageUsed = normalDamage;
            cooldownUsed = normalCooldown;
            break;
          case 2:
            bulletSpeedUsed = rpgSpeed;
            bulletDamageUsed = rpgDamage;
            cooldownUsed = rpgCooldown;
            break;
          case 3:
            bulletSpeedUsed = rapidSpeed;
            bulletDamageUsed = rapidDamage;
            cooldownUsed = rapidCooldown;
            break;
        }
        if (Phaser.Input.Keyboard.JustDown(spaceKey) && time > lastShotTime + cooldownUsed) {
          const bulletDir = new Phaser.Math.Vector2(Math.cos(localTank.rotation), Math.sin(localTank.rotation));
          const vx = bulletDir.x * bulletSpeedUsed;
          const vy = bulletDir.y * bulletSpeedUsed;
          const bulletRef = push(ref(db, "bullets"));
          const bulletData = {
            shooter: playerId,
            weapon: currentWeapon,
            damage: bulletDamageUsed,
            x: localTank.x,
            y: localTank.y,
            vx: vx,
            vy: vy,
            timestamp: Date.now()
          };
          set(bulletRef, bulletData);
          lastShotTime = time;
        }
        
        // --- Explosion Helper Function ---
        function triggerExplosion(b, bulletKey) {
          let explosion = scene.add.circle(b.x, b.y, explosionRadius, 0xffaa00, 0.5);
          scene.tweens.add({
            targets: explosion,
            alpha: 0,
            duration: 500,
            onComplete: () => explosion.destroy()
          });
          // Damage local tank if within explosion radius
          let dx = localTank.x - b.x;
          let dy = localTank.y - b.y;
          if (Math.sqrt(dx * dx + dy * dy) <= explosionRadius) {
            localTank.health -= explosionDamage;
            if (localTank.health <= 0 && !gameOverTriggered) {
              gameOverTriggered = true;
              localTank.setTint(0xff0000);
              localTank.setVelocity(0);
              window.location.href = "https://example.com/gameover.html";
            }
          }
          // Damage remote tanks
          for (const pid in otherPlayers) {
            let remote = otherPlayers[pid].sprite;
            let dx2 = remote.x - b.x;
            let dy2 = remote.y - b.y;
            if (Math.sqrt(dx2 * dx2 + dy2 * dy2) <= explosionRadius) {
              let newHealth = remote.health - explosionDamage;
              set(ref(db, "players/" + pid), {
                x: remote.x,
                y: remote.y,
                rotation: remote.rotation,
                username: otherPlayers[pid].username || "",
                health: newHealth,
                lastPing: Date.now()
              });
            }
          }
          set(ref(db, "bullets/" + bulletKey), null);
        }
        
        // --- Bullet Collision Detection ---
        for (const key in bulletMap) {
          const b = bulletMap[key];
          // Remove bullet if off screen
          if (b.x < 0 || b.x > scene.cameras.main.width || b.y < 0 || b.y > scene.cameras.main.height) {
            set(ref(db, "bullets/" + key), null);
            continue;
          }
          // If bullet fired by another player, check collision with local tank
          if (b.shooter !== playerId) {
            if (Phaser.Geom.Intersects.RectangleToRectangle(b.getBounds(), localTank.getBounds())) {
              if (b.weaponType === 2) {
                triggerExplosion(b, key);
              } else {
                localTank.health -= b.damage;
                if (localTank.health <= 0 && !gameOverTriggered) {
                  gameOverTriggered = true;
                  localTank.setTint(0xff0000);
                  localTank.setVelocity(0);
                  window.location.href = "https://example.com/gameover.html";
                }
                set(ref(db, "bullets/" + key), null);
              }
              continue;
            }
          } else {
            // Bullet fired locally: check collision with remote tanks
            for (const pid in otherPlayers) {
              const remote = otherPlayers[pid].sprite;
              if (Phaser.Geom.Intersects.RectangleToRectangle(b.getBounds(), remote.getBounds())) {
                if (b.weaponType === 2) {
                  triggerExplosion(b, key);
                } else {
                  const newHealth = remote.health - b.damage;
                  set(ref(db, "players/" + pid), {
                    x: remote.x,
                    y: remote.y,
                    rotation: remote.rotation,
                    username: otherPlayers[pid].username || "",
                    health: newHealth,
                    lastPing: Date.now()
                  });
                  set(ref(db, "bullets/" + key), null);
                }
                break;
              }
            }
          }
        }
        
        // --- Update Local Player State in Firebase ---
        set(ref(db, "players/" + playerId), {
          x: localTank.x,
          y: localTank.y,
          rotation: localTank.rotation,
          username: username,
          health: localTank.health,
          lastPing: Date.now()
        });
        
        // --- Update Health Bars ---
        drawHealthBar(localTank, localHealthBar, localTank.health, localTank.maxHealth);
        for (const pid in otherPlayers) {
          const remoteObj = otherPlayers[pid];
          drawHealthBar(remoteObj.sprite, remoteObj.healthBar, remoteObj.sprite.health, remoteObj.sprite.maxHealth);
        }
        
        // --- Remove Offline Remote Players ---
        const offlineThreshold = 10000; // 10 seconds
        for (const pid in otherPlayers) {
          if (Date.now() - otherPlayers[pid].lastPing > offlineThreshold) {
            otherPlayers[pid].sprite.destroy();
            otherPlayers[pid].healthBar.destroy();
            delete otherPlayers[pid];
          }
        }
      }
      
      // Remove local player entry when the window unloads
      window.addEventListener('beforeunload', () => {
        set(ref(db, "players/" + playerId), null);
      });
    }
  </script>
</body>
</html>
