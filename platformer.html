<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Top Down Tank Game â€“ Multiplayer (Fullscreen & Fixed Shield Behavior)</title>
  <style>
    body { margin: 0; overflow: hidden; background: #333; }
    /* Fullscreen game container */
    #game-container {
      width: 100vw;
      height: 100vh;
      display: none;
      position: relative;
    }
    /* Centered overlay for login and game over */
    #login-container, #gameover-container {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 300px;
      background: rgba(0,0,0,0.8);
      color: #fff;
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      z-index: 1001;
    }
    #login-container input, #gameover-container button, #login-container button {
      width: 80%;
      padding: 8px;
      margin: 10px 0;
    }
    #gameover-container { display: none; }
    /* Canvas fills the game container */
    #gameCanvas {
      background: #808080;
      display: block;
    }
  </style>
</head>
<body>
  <!-- Login Overlay -->
  <div id="login-container">
    <h2>Enter Name</h2>
    <input type="text" id="username-input" placeholder="Enter your username" />
    <br/>
    <button id="login-button">Start Game</button>
  </div>
  
  <!-- Game Container -->
  <div id="game-container">
    <canvas id="gameCanvas"></canvas>
  </div>
  
  <!-- Game Over Overlay -->
  <div id="gameover-container">
    <h2>Game Over</h2>
    <button id="restart-button">Restart Game</button>
  </div>
  
  <script type="module">
    // Import Firebase modules
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-app.js";
    import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-analytics.js";
    import { getDatabase, ref, set, onChildAdded, onChildChanged, onChildRemoved, push } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-database.js";
    
    // Firebase configuration (using your config)
    const firebaseConfig = {
      apiKey: "AIzaSyCssnOBJd20Q46CVF4iuuygLeqaMCqInhk",
      authDomain: "platformer-e205c.firebaseapp.com",
      projectId: "platformer-e205c",
      storageBucket: "platformer-e205c.firebasestorage.app",
      messagingSenderId: "350613298525",
      appId: "1:350613298525:web:dddba101b6545241dadcb4",
      measurementId: "G-3DT5KYV4MS"
    };
    
    const appFirebase = initializeApp(firebaseConfig);
    const analytics = getAnalytics(appFirebase);
    const db = getDatabase(appFirebase);
    
    let username = "";
    let playerId = "";
    
    // Shield radius constant
    const SHIELD_RADIUS = 50;
    
    // Login handling
    document.getElementById("login-button").addEventListener("click", () => {
      const input = document.getElementById("username-input").value.trim();
      if (input !== "") {
        username = input;
        // Create a unique id for this session
        playerId = "player_" + Math.floor(Math.random() * 10000);
        document.getElementById("login-container").style.display = "none";
        document.getElementById("game-container").style.display = "block";
        startGame();
      }
    });
    
    function startGame() {
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      
      // Set canvas to fullscreen and update on window resize
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
      
      // Local player definition
      let localPlayer = {
        id: playerId,
        username: username,
        x: canvas.width / 2,
        y: canvas.height / 2,
        rotation: 0,
        health: 100,
        maxHealth: 100,
        shield: (username.toLowerCase() === "pranav1")
      };
      
      // Store remote players and bullets
      let remotePlayers = {};
      let bullets = [];
      
      // Crates (obstacles) defined as rectangles
      let crates = [
        { x: 125, y: 125, width: 50, height: 50 },
        { x: canvas.width - 175, y: 125, width: 50, height: 50 },
        { x: 125, y: canvas.height - 175, width: 50, height: 50 },
        { x: canvas.width - 175, y: canvas.height - 175, width: 50, height: 50 },
        { x: canvas.width/2 - 25, y: canvas.height/2 - 75, width: 50, height: 50 }
      ];
      
      // Keyboard input handling; convert keys to lowercase
      let keys = {};
      window.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
      window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);
      
      // Weapon settings
      let currentWeapon = 1; // 1: Normal, 2: RPG, 3: Rapid Fire
      let lastShotTime = 0;
      const weaponParams = {
        1: { damage: 25, cooldown: 500, speed: 300 },
        2: { damage: 50, cooldown: 1000, speed: 200, explosionDamage: 100 },
        3: { damage: 15, cooldown: 200, speed: 300 }
      };
      
      // When shooting, if the player has a shield, spawn the bullet outside the shield.
      function shootBullet(angle, speed, damage, weaponType) {
        const now = Date.now();
        let offset = localPlayer.shield ? (SHIELD_RADIUS + 10) : 0;
        let startX = localPlayer.x + Math.cos(angle) * offset;
        let startY = localPlayer.y + Math.sin(angle) * offset;
        let bullet = {
          id: "bullet_" + Math.floor(Math.random() * 1000000),
          shooter: playerId,
          weapon: weaponType,
          damage: damage,
          x: startX,
          y: startY,
          vx: Math.cos(angle) * speed / 1000,
          vy: Math.sin(angle) * speed / 1000,
          timestamp: now,
          deflected: false
        };
        bullets.push(bullet);
        let bulletRef = push(ref(db, "bullets"));
        set(bulletRef, bullet);
      }
      
      function shoot() {
        const now = Date.now();
        if (now - lastShotTime < weaponParams[currentWeapon].cooldown) return;
        lastShotTime = now;
        shootBullet(localPlayer.rotation, weaponParams[currentWeapon].speed, weaponParams[currentWeapon].damage, currentWeapon);
      }
      
      function handleShooting() {
        if (currentWeapon === 2 && username.toLowerCase() === "reed" && keys[" "]) {
          const now = Date.now();
          if (now - lastShotTime < 0) return;
          lastShotTime = now;
          const numPellets = 50;
          const spreadRangeDeg = 20;
          for (let i = 0; i < numPellets; i++) {
            let offsetDeg = -spreadRangeDeg/2 + (i * spreadRangeDeg / (numPellets - 1));
            let angle = localPlayer.rotation + offsetDeg * (Math.PI/180);
            shootBullet(angle, weaponParams[2].speed, weaponParams[2].damage, currentWeapon);
          }
        }
        else if (currentWeapon === 2 && username.toLowerCase() === "pranav" && keys[" "]) {
          const now = Date.now();
          if (now - lastShotTime < 50) return;
          lastShotTime = now;
          shootBullet(localPlayer.rotation, weaponParams[2].speed, weaponParams[2].damage, currentWeapon);
        }
        else if (keys[" "]) {
          shoot();
        }
      }
      
      // Simple circle-rectangle collision (for tank vs crate)
      function circleRectCollision(cx, cy, radius, rx, ry, rw, rh) {
        let closestX = Math.max(rx, Math.min(cx, rx + rw));
        let closestY = Math.max(ry, Math.min(cy, ry + rh));
        let dx = cx - closestX;
        let dy = cy - closestY;
        return (dx * dx + dy * dy) < (radius * radius);
      }
      
      let lastTime = performance.now();
      function gameLoop(currentTime) {
        let dt = (currentTime - lastTime) / 1000;
        lastTime = currentTime;
        update(dt);
        draw();
        requestAnimationFrame(gameLoop);
      }
      requestAnimationFrame(gameLoop);
      
      function update(dt) {
        // Weapon selection (keys "1", "2", "3")
        if (keys["1"]) currentWeapon = 1;
        if (keys["2"]) currentWeapon = 2;
        if (keys["3"]) currentWeapon = 3;
        
        // Save previous position for collision reversion
        let prevX = localPlayer.x;
        let prevY = localPlayer.y;
        
        const TANK_SPEED = 150;
        const ROTATION_SPEED = Math.PI;
        if (keys["a"]) localPlayer.rotation -= ROTATION_SPEED * dt;
        if (keys["d"]) localPlayer.rotation += ROTATION_SPEED * dt;
        if (keys["w"]) {
          localPlayer.x += Math.cos(localPlayer.rotation) * TANK_SPEED * dt;
          localPlayer.y += Math.sin(localPlayer.rotation) * TANK_SPEED * dt;
        }
        if (keys["s"]) {
          localPlayer.x -= Math.cos(localPlayer.rotation) * TANK_SPEED * dt;
          localPlayer.y -= Math.sin(localPlayer.rotation) * TANK_SPEED * dt;
        }
        
        // Check for crate collisions; if colliding, revert
        for (let crate of crates) {
          if (circleRectCollision(localPlayer.x, localPlayer.y, 20, crate.x, crate.y, crate.width, crate.height)) {
            localPlayer.x = prevX;
            localPlayer.y = prevY;
            break;
          }
        }
        
        // Constrain local player within canvas bounds
        localPlayer.x = Math.max(0, Math.min(canvas.width, localPlayer.x));
        localPlayer.y = Math.max(0, Math.min(canvas.height, localPlayer.y));
        
        handleShooting();
        
        // Update bullets and handle collisions
        for (let i = bullets.length - 1; i >= 0; i--) {
          let b = bullets[i];
          b.x += b.vx * dt * 1000;
          b.y += b.vy * dt * 1000;
          
          // Remove bullet if off-screen or too old
          if (b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height || Date.now() - b.timestamp > 5000) {
            set(ref(db, "bullets/" + b.id), null);
            bullets.splice(i, 1);
            continue;
          }
          
          // Check collision with crates
          let hitCrate = false;
          for (let crate of crates) {
            if (b.x > crate.x && b.x < crate.x + crate.width &&
                b.y > crate.y && b.y < crate.y + crate.height) {
              hitCrate = true;
              break;
            }
          }
          if (hitCrate) {
            set(ref(db, "bullets/" + b.id), null);
            bullets.splice(i, 1);
            continue;
          }
          
          // Check collision with local player's shield
          if (localPlayer.shield) {
            let dx = b.x - localPlayer.x;
            let dy = b.y - localPlayer.y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < SHIELD_RADIUS) {
              if (!b.deflected) {
                let nx = dx / dist, ny = dy / dist;
                let dot = b.vx * nx + b.vy * ny;
                b.vx = b.vx - 2 * dot * nx;
                b.vy = b.vy - 2 * dot * ny;
                b.x = localPlayer.x + nx * (SHIELD_RADIUS + 5);
                b.y = localPlayer.y + ny * (SHIELD_RADIUS + 5);
                b.deflected = true;
                set(ref(db, "bullets/" + b.id), b);
              }
            }
          }
          
          // Check collision with remote players' shields
          for (let id in remotePlayers) {
            let rp = remotePlayers[id];
            if (rp.shield) {
              let dx = b.x - rp.x;
              let dy = b.y - rp.y;
              let dist = Math.sqrt(dx*dx + dy*dy);
              if (dist < SHIELD_RADIUS) {
                if (!b.deflected) {
                  let nx = dx / dist, ny = dy / dist;
                  let dot = b.vx * nx + b.vy * ny;
                  b.vx = b.vx - 2 * dot * nx;
                  b.vy = b.vy - 2 * dot * ny;
                  b.x = rp.x + nx * (SHIELD_RADIUS + 5);
                  b.y = rp.y + ny * (SHIELD_RADIUS + 5);
                  b.deflected = true;
                  set(ref(db, "bullets/" + b.id), b);
                }
                break;
              }
            }
          }
          
          // Collision with tanks:
          // For bullets that have already been deflected, remove them immediately on impact.
          if (b.shooter !== playerId) {
            let dx = b.x - localPlayer.x, dy = b.y - localPlayer.y;
            if (Math.sqrt(dx*dx + dy*dy) < 20) {
              if(b.deflected) {
                set(ref(db, "bullets/" + b.id), null);
                bullets.splice(i, 1);
                continue;
              } else {
                if (b.weapon === 2)
                  localPlayer.health -= weaponParams[2].explosionDamage;
                else
                  localPlayer.health -= b.damage;
                set(ref(db, "bullets/" + b.id), null);
                bullets.splice(i, 1);
                if (localPlayer.health <= 0) gameOver();
                continue;
              }
            }
          } else {
            for (let id in remotePlayers) {
              let rp = remotePlayers[id];
              let dx = b.x - rp.x, dy = b.y - rp.y;
              if (Math.sqrt(dx*dx + dy*dy) < 20) {
                if(b.deflected) {
                  set(ref(db, "bullets/" + b.id), null);
                  bullets.splice(i, 1);
                  break;
                } else {
                  if (b.weapon === 2)
                    rp.health -= weaponParams[2].explosionDamage;
                  else
                    rp.health -= b.damage;
                  set(ref(db, "players/" + id), rp);
                  set(ref(db, "bullets/" + b.id), null);
                  bullets.splice(i, 1);
                  break;
                }
              }
            }
          }
        }
        
        // Remove remote players who haven't pinged recently
        for (let id in remotePlayers) {
          if (Date.now() - remotePlayers[id].lastPing > 10000) {
            delete remotePlayers[id];
          }
        }
        
        // Update local player state to Firebase
        set(ref(db, "players/" + playerId), {
          x: localPlayer.x,
          y: localPlayer.y,
          rotation: localPlayer.rotation,
          username: localPlayer.username,
          health: localPlayer.health,
          maxHealth: localPlayer.maxHealth,
          lastPing: Date.now(),
          shield: localPlayer.shield
        });
      }
      
      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#808080";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#8B4513";
        for (let crate of crates) {
          ctx.fillRect(crate.x, crate.y, crate.width, crate.height);
          ctx.strokeStyle = "#000";
          ctx.strokeRect(crate.x, crate.y, crate.width, crate.height);
        }
        ctx.save();
        ctx.translate(localPlayer.x, localPlayer.y);
        ctx.rotate(localPlayer.rotation);
        ctx.fillStyle = "#333333";
        ctx.fillRect(-30, -15, 60, 30);
        ctx.fillStyle = "#777777";
        ctx.beginPath();
        ctx.arc(0, 0, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#555555";
        ctx.fillRect(8, -2, 20, 4);
        ctx.restore();
        if (localPlayer.shield) {
          ctx.beginPath();
          ctx.arc(localPlayer.x, localPlayer.y, SHIELD_RADIUS, 0, Math.PI * 2);
          ctx.fillStyle = "rgba(0,255,255,0.3)";
          ctx.fill();
        }
        for (let id in remotePlayers) {
          let rp = remotePlayers[id];
          ctx.save();
          ctx.translate(rp.x, rp.y);
          ctx.rotate(rp.rotation);
          ctx.fillStyle = "#333333";
          ctx.fillRect(-30, -15, 60, 30);
          ctx.fillStyle = "#777777";
          ctx.beginPath();
          ctx.arc(0, 0, 8, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#555555";
          ctx.fillRect(8, -2, 20, 4);
          ctx.restore();
          if (rp.shield) {
            ctx.beginPath();
            ctx.arc(rp.x, rp.y, SHIELD_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(0,255,255,0.3)";
            ctx.fill();
          }
          ctx.fillStyle = "#fff";
          ctx.font = "12px sans-serif";
          ctx.textAlign = "center";
          ctx.fillText(rp.username, rp.x, rp.y - 20);
          let barWidth = 40, barHeight = 6;
          let healthPercent = Math.max(0, rp.health / rp.maxHealth);
          ctx.fillStyle = "#000";
          ctx.fillRect(rp.x - barWidth/2, rp.y - 30, barWidth, barHeight);
          ctx.fillStyle = "#0f0";
          ctx.fillRect(rp.x - barWidth/2 + 1, rp.y - 30 + 1, (barWidth - 2) * healthPercent, barHeight - 2);
        }
        ctx.fillStyle = "#fff";
        ctx.font = "12px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(localPlayer.username, localPlayer.x, localPlayer.y - 20);
        let barWidth = 40, barHeight = 6;
        let healthPercent = Math.max(0, localPlayer.health / localPlayer.maxHealth);
        ctx.fillStyle = "#000";
        ctx.fillRect(localPlayer.x - barWidth/2, localPlayer.y - 30, barWidth, barHeight);
        ctx.fillStyle = "#0f0";
        ctx.fillRect(localPlayer.x - barWidth/2 + 1, localPlayer.y - 30 + 1, (barWidth - 2) * healthPercent, barHeight - 2);
        ctx.fillStyle = "#ff4500";
        for (let b of bullets) {
          ctx.beginPath();
          ctx.arc(b.x, b.y, 4, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      function gameOver() {
        document.getElementById("gameover-container").style.display = "block";
        set(ref(db, "players/" + playerId), null);
      }
      
      const playersRef = ref(db, "players");
      onChildAdded(playersRef, (data) => {
        if (data.key === playerId) return;
        remotePlayers[data.key] = data.val();
      });
      onChildChanged(playersRef, (data) => {
        if (data.key === playerId) return;
        remotePlayers[data.key] = data.val();
      });
      onChildRemoved(playersRef, (data) => {
        if (remotePlayers[data.key]) delete remotePlayers[data.key];
      });
      
      const bulletsRef = ref(db, "bullets");
      onChildAdded(bulletsRef, (data) => {
        let bData = data.val();
        if (Date.now() - bData.timestamp < 3000) {
          if (!bullets.find(b => b.id === data.key)) {
            bullets.push(bData);
          }
        } else {
          set(ref(db, "bullets/" + data.key), null);
        }
      });
      onChildRemoved(bulletsRef, (data) => {
        bullets = bullets.filter(b => b.id !== data.key);
      });
      
      window.addEventListener('beforeunload', () => {
        set(ref(db, "players/" + playerId), null);
      });
      
      document.getElementById("restart-button").addEventListener("click", () => {
        window.location.reload();
      });
    }
  </script>
</body>
</html>
