<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Top Down Tank Game – Multiplayer with Custom Shooting</title>
  <style>
    body { margin: 0; overflow: hidden; background: #333; }
    /* Fullscreen game container */
    #game-container {
      width: 100vw;
      height: 100vh;
      display: none;
      position: relative;
    }
    /* Centered overlay for login and game over */
    #login-container, #gameover-container {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 300px;
      background: rgba(0,0,0,0.8);
      color: #fff;
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      z-index: 1001;
    }
    #login-container input, #gameover-container button, #login-container button {
      width: 80%;
      padding: 8px;
      margin: 10px 0;
    }
    #gameover-container { display: none; }
    /* Canvas fills the game container */
    #gameCanvas {
      background: #808080;
      display: block;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <!-- Login Overlay -->
  <div id="login-container">
    <h2>Enter Name</h2>
    <input type="text" id="username-input" placeholder="Enter your username" />
    <br/>
    <button id="login-button">Start Game</button>
  </div>
  
  <!-- Game Container -->
  <div id="game-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
  </div>
  
  <!-- Game Over Overlay -->
  <div id="gameover-container">
    <h2>Game Over</h2>
    <button id="restart-button">Restart Game</button>
  </div>
  
  <script type="module">
    // Import Firebase modules
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-app.js";
    import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-analytics.js";
    import { getDatabase, ref, set, onChildAdded, onChildChanged, onChildRemoved, push } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-database.js";
    
    // Firebase configuration (using your config)
    const firebaseConfig = {
      apiKey: "AIzaSyCssnOBJd20Q46CVF4iuuygLeqaMCqInhk",
      authDomain: "platformer-e205c.firebaseapp.com",
      projectId: "platformer-e205c",
      storageBucket: "platformer-e205c.firebasestorage.app",
      messagingSenderId: "350613298525",
      appId: "1:350613298525:web:dddba101b6545241dadcb4",
      measurementId: "G-3DT5KYV4MS"
    };
    
    // Initialize Firebase
    const appFirebase = initializeApp(firebaseConfig);
    const analytics = getAnalytics(appFirebase);
    const db = getDatabase(appFirebase);
    
    // Global login variables
    let username = "";
    let playerId = "";
    
    // Constants
    const SHIELD_RADIUS = 50;
    
    // Login handling
    document.getElementById("login-button").addEventListener("click", () => {
      const input = document.getElementById("username-input").value.trim();
      if (input !== "") {
        username = input;
        // Create a unique id
        playerId = "player_" + Math.floor(Math.random() * 10000);
        document.getElementById("login-container").style.display = "none";
        document.getElementById("game-container").style.display = "block";
        startGame();
      }
    });
    
    // --- Game Code (No Phaser) ---
    function startGame() {
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      
      // Local player object
      let localPlayer = {
        id: playerId,
        username: username,
        x: canvas.width / 2,
        y: canvas.height / 2,
        rotation: 0, // in radians
        health: 100,
        maxHealth: 100,
        shield: (username.toLowerCase() === "pranav1")
      };
      
      // Remote players and bullets storage
      let remotePlayers = {}; // key: id, value: player object (same properties as localPlayer)
      let bullets = [];     // each bullet: { id, shooter, weapon, damage, x, y, vx, vy, timestamp }
      
      // Crates (obstacles) as rectangles
      let crates = [
        { x: 150 - 25, y: 150 - 25, width: 50, height: 50 },
        { x: 650 - 25, y: 150 - 25, width: 50, height: 50 },
        { x: 150 - 25, y: 450 - 25, width: 50, height: 50 },
        { x: 650 - 25, y: 450 - 25, width: 50, height: 50 },
        { x: 400 - 25, y: 300 - 25, width: 50, height: 50 }
      ];
      
      // Keyboard input handling
      let keys = {};
      window.addEventListener("keydown", e => keys[e.key] = true);
      window.addEventListener("keyup", e => keys[e.key] = false);
      
      // Weapon settings
      // 1: Normal, 2: RPG, 3: Rapid Fire
      let currentWeapon = 1;
      let lastShotTime = 0;
      const weaponParams = {
        1: { damage: 25, cooldown: 500, speed: 300 },
        2: { damage: 50, cooldown: 1000, speed: 200, explosionRadius: 75, explosionDamage: 100 },
        3: { damage: 15, cooldown: 200, speed: 300 }
      };
      
      // --- Shooting Functions ---
      function shootBullet(angle, speed, damage, weaponType) {
        const now = Date.now();
        let bullet = {
          id: "bullet_" + Math.floor(Math.random() * 1000000),
          shooter: playerId,
          weapon: weaponType,
          damage: damage,
          x: localPlayer.x,
          y: localPlayer.y,
          // Velocity in pixels per millisecond
          vx: Math.cos(angle) * speed / 1000,
          vy: Math.sin(angle) * speed / 1000,
          timestamp: now
        };
        bullets.push(bullet);
        let bulletRef = push(ref(db, "bullets"));
        set(bulletRef, bullet);
      }
      
      // Default shooting behavior
      function shoot() {
        const now = Date.now();
        if (now - lastShotTime < weaponParams[currentWeapon].cooldown) return;
        lastShotTime = now;
        shootBullet(localPlayer.rotation, weaponParams[currentWeapon].speed, weaponParams[currentWeapon].damage, currentWeapon);
      }
      
      // Special cases for shotgun spread and rapid-fire for certain usernames
      function handleShooting() {
        // "reed" with RPG: shotgun spread (50 pellets)
        if (currentWeapon === 2 && username.toLowerCase() === "reed" && keys[" "]) {
          const now = Date.now();
          if (now - lastShotTime < 0) return;
          lastShotTime = now;
          const numPellets = 50;
          const spreadRangeDeg = 20; // smaller spread for clarity
          for (let i = 0; i < numPellets; i++) {
            let offsetDeg = -spreadRangeDeg/2 + (i * spreadRangeDeg / (numPellets - 1));
            let angle = localPlayer.rotation + offsetDeg * (Math.PI/180);
            shootBullet(angle, weaponParams[2].speed, weaponParams[2].damage, currentWeapon);
          }
        }
        // "pranav" with RPG: rapid fire every 50ms
        else if (currentWeapon === 2 && username.toLowerCase() === "pranav" && keys[" "]) {
          const now = Date.now();
          if (now - lastShotTime < 50) return;
          lastShotTime = now;
          shootBullet(localPlayer.rotation, weaponParams[2].speed, weaponParams[2].damage, currentWeapon);
        }
        // Default shooting for all others
        else if (keys[" "]) {
          shoot();
        }
      }
      
      // --- Game Loop ---
      let lastTime = performance.now();
      function gameLoop(currentTime) {
        let dt = (currentTime - lastTime) / 1000; // seconds
        lastTime = currentTime;
        update(dt);
        draw();
        requestAnimationFrame(gameLoop);
      }
      requestAnimationFrame(gameLoop);
      
      // Update game state (movement, bullets, collisions)
      function update(dt) {
        // Weapon selection (keys "1", "2", "3")
        if (keys["1"]) currentWeapon = 1;
        if (keys["2"]) currentWeapon = 2;
        if (keys["3"]) currentWeapon = 3;
        
        // Movement – WASD (rotate with A/D; forward/back with W/S)
        const TANK_SPEED = 150; // pixels per second
        const ROTATION_SPEED = Math.PI; // radians per second
        if (keys["a"]) localPlayer.rotation -= ROTATION_SPEED * dt;
        if (keys["d"]) localPlayer.rotation += ROTATION_SPEED * dt;
        if (keys["w"]) {
          localPlayer.x += Math.cos(localPlayer.rotation) * TANK_SPEED * dt;
          localPlayer.y += Math.sin(localPlayer.rotation) * TANK_SPEED * dt;
        }
        if (keys["s"]) {
          localPlayer.x -= Math.cos(localPlayer.rotation) * TANK_SPEED * dt;
          localPlayer.y -= Math.sin(localPlayer.rotation) * TANK_SPEED * dt;
        }
        // Constrain local player within canvas bounds
        localPlayer.x = Math.max(0, Math.min(canvas.width, localPlayer.x));
        localPlayer.y = Math.max(0, Math.min(canvas.height, localPlayer.y));
        
        // Handle shooting based on key input
        handleShooting();
        
        // Update bullets and handle collisions
        for (let i = bullets.length - 1; i >= 0; i--) {
          let b = bullets[i];
          // Update position (vx, vy are in pixels/ms; dt in seconds so multiply by 1000)
          b.x += b.vx * dt * 1000;
          b.y += b.vy * dt * 1000;
          
          // Remove bullet if off-screen
          if (b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) {
            set(ref(db, "bullets/" + b.id), null);
            bullets.splice(i, 1);
            continue;
          }
          
          // Check collision with crates (simple rectangle collision)
          let hitCrate = false;
          for (let crate of crates) {
            if (b.x > crate.x && b.x < crate.x + crate.width &&
                b.y > crate.y && b.y < crate.y + crate.height) {
              hitCrate = true;
              break;
            }
          }
          if (hitCrate) {
            // For RPG, you might trigger an explosion (omitted for brevity)
            set(ref(db, "bullets/" + b.id), null);
            bullets.splice(i, 1);
            continue;
          }
          
          // Check collision with shields (local player's shield)
          if (localPlayer.shield) {
            let dx = b.x - localPlayer.x;
            let dy = b.y - localPlayer.y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < SHIELD_RADIUS) {
              // Reflect bullet velocity using vector reflection:
              // v' = v - 2*(v · n)*n  where n is the normalized vector from shield center to bullet
              let nx = dx / dist, ny = dy / dist;
              let dot = b.vx * nx + b.vy * ny;
              b.vx = b.vx - 2 * dot * nx;
              b.vy = b.vy - 2 * dot * ny;
              // Nudge the bullet outside the shield so it doesn’t stick
              b.x = localPlayer.x + nx * (SHIELD_RADIUS + 5);
              b.y = localPlayer.y + ny * (SHIELD_RADIUS + 5);
              set(ref(db, "bullets/" + b.id), b);
              continue;
            }
          }
          // Check collision with remote players’ shields
          for (let id in remotePlayers) {
            let rp = remotePlayers[id];
            if (rp.shield) {
              let dx = b.x - rp.x;
              let dy = b.y - rp.y;
              let dist = Math.sqrt(dx*dx + dy*dy);
              if (dist < SHIELD_RADIUS) {
                let nx = dx / dist, ny = dy / dist;
                let dot = b.vx * nx + b.vy * ny;
                b.vx = b.vx - 2 * dot * nx;
                b.vy = b.vy - 2 * dot * ny;
                b.x = rp.x + nx * (SHIELD_RADIUS + 5);
                b.y = rp.y + ny * (SHIELD_RADIUS + 5);
                set(ref(db, "bullets/" + b.id), b);
                break;
              }
            }
          }
          
          // Check collision with tanks (using a circle radius of 20 for hit detection)
          // If bullet is fired by another player and hits local tank:
          if (b.shooter !== playerId) {
            let dx = b.x - localPlayer.x, dy = b.y - localPlayer.y;
            if (Math.sqrt(dx*dx + dy*dy) < 20) {
              if (b.weapon === 2)
                localPlayer.health -= weaponParams[2].explosionDamage;
              else
                localPlayer.health -= b.damage;
              set(ref(db, "bullets/" + b.id), null);
              bullets.splice(i, 1);
              if (localPlayer.health <= 0) gameOver();
              continue;
            }
          } else {
            // For bullets fired by local player, check collision with remote players
            for (let id in remotePlayers) {
              let rp = remotePlayers[id];
              let dx = b.x - rp.x, dy = b.y - rp.y;
              if (Math.sqrt(dx*dx + dy*dy) < 20) {
                if (b.weapon === 2)
                  rp.health -= weaponParams[2].explosionDamage;
                else
                  rp.health -= b.damage;
                set(ref(db, "players/" + id), rp);
                set(ref(db, "bullets/" + b.id), null);
                bullets.splice(i, 1);
                break;
              }
            }
          }
        }
        
        // Update local player state in Firebase (include shield flag)
        set(ref(db, "players/" + playerId), {
          x: localPlayer.x,
          y: localPlayer.y,
          rotation: localPlayer.rotation,
          username: localPlayer.username,
          health: localPlayer.health,
          maxHealth: localPlayer.maxHealth,
          lastPing: Date.now(),
          shield: localPlayer.shield
        });
      }
      
      // Draw everything on the canvas
      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // Draw background
        ctx.fillStyle = "#808080";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        // Draw crates
        ctx.fillStyle = "#8B4513";
        for (let crate of crates) {
          ctx.fillRect(crate.x, crate.y, crate.width, crate.height);
          ctx.strokeStyle = "#000";
          ctx.strokeRect(crate.x, crate.y, crate.width, crate.height);
        }
        // Draw local player tank (as a rotated rectangle with a turret)
        ctx.save();
        ctx.translate(localPlayer.x, localPlayer.y);
        ctx.rotate(localPlayer.rotation);
        ctx.fillStyle = "#333333";
        ctx.fillRect(-30, -15, 60, 30);
        ctx.fillStyle = "#777777";
        ctx.beginPath();
        ctx.arc(0, 0, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#555555";
        ctx.fillRect(8, -2, 20, 4);
        ctx.restore();
        // Draw local shield if active
        if (localPlayer.shield) {
          ctx.beginPath();
          ctx.arc(localPlayer.x, localPlayer.y, SHIELD_RADIUS, 0, Math.PI * 2);
          ctx.fillStyle = "rgba(0,255,255,0.3)";
          ctx.fill();
        }
        // Draw remote players
        for (let id in remotePlayers) {
          let rp = remotePlayers[id];
          ctx.save();
          ctx.translate(rp.x, rp.y);
          ctx.rotate(rp.rotation);
          ctx.fillStyle = "#333333";
          ctx.fillRect(-30, -15, 60, 30);
          ctx.fillStyle = "#777777";
          ctx.beginPath();
          ctx.arc(0, 0, 8, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#555555";
          ctx.fillRect(8, -2, 20, 4);
          ctx.restore();
          if (rp.shield) {
            ctx.beginPath();
            ctx.arc(rp.x, rp.y, SHIELD_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(0,255,255,0.3)";
            ctx.fill();
          }
          // Draw username and health bar above remote tank
          ctx.fillStyle = "#fff";
          ctx.font = "12px sans-serif";
          ctx.textAlign = "center";
          ctx.fillText(rp.username, rp.x, rp.y - 20);
          let barWidth = 40, barHeight = 6;
          let healthPercent = Math.max(0, rp.health / rp.maxHealth);
          ctx.fillStyle = "#000";
          ctx.fillRect(rp.x - barWidth/2, rp.y - 30, barWidth, barHeight);
          ctx.fillStyle = "#0f0";
          ctx.fillRect(rp.x - barWidth/2 + 1, rp.y - 30 + 1, (barWidth - 2) * healthPercent, barHeight - 2);
        }
        // Draw local username and health bar
        ctx.fillStyle = "#fff";
        ctx.font = "12px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(localPlayer.username, localPlayer.x, localPlayer.y - 20);
        let barWidth = 40, barHeight = 6;
        let healthPercent = Math.max(0, localPlayer.health / localPlayer.maxHealth);
        ctx.fillStyle = "#000";
        ctx.fillRect(localPlayer.x - barWidth/2, localPlayer.y - 30, barWidth, barHeight);
        ctx.fillStyle = "#0f0";
        ctx.fillRect(localPlayer.x - barWidth/2 + 1, localPlayer.y - 30 + 1, (barWidth - 2) * healthPercent, barHeight - 2);
        // Draw bullets
        ctx.fillStyle = "#ff4500";
        for (let b of bullets) {
          ctx.beginPath();
          ctx.arc(b.x, b.y, 4, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      // End-game: show game over overlay and remove player from Firebase
      function gameOver() {
        document.getElementById("gameover-container").style.display = "block";
        set(ref(db, "players/" + playerId), null);
      }
      
      // --- Firebase Listeners ---
      const playersRef = ref(db, "players");
      onChildAdded(playersRef, (data) => {
        if (data.key === playerId) return;
        remotePlayers[data.key] = data.val();
      });
      onChildChanged(playersRef, (data) => {
        if (data.key === playerId) return;
        remotePlayers[data.key] = data.val();
      });
      onChildRemoved(playersRef, (data) => {
        if (remotePlayers[data.key]) delete remotePlayers[data.key];
      });
      
      const bulletsRef = ref(db, "bullets");
      onChildAdded(bulletsRef, (data) => {
        let bData = data.val();
        if (!bullets.find(b => b.id === data.key)) {
          bullets.push(bData);
        }
      });
      onChildRemoved(bulletsRef, (data) => {
        bullets = bullets.filter(b => b.id !== data.key);
      });
      
      // Clean up Firebase on window unload
      window.addEventListener('beforeunload', () => {
        set(ref(db, "players/" + playerId), null);
      });
      
      // Restart button reloads the page
      document.getElementById("restart-button").addEventListener("click", () => {
        window.location.reload();
      });
    }
  </script>
</body>
</html>
